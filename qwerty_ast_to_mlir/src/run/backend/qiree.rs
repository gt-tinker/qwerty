use super::super::ShotResult;
use dashu::integer::UBig;
use melior::{
    ir::Module,
    target::llvm_ir::{LLVMContext, translate_module},
};
use qiree_sys::{
    CQireeResultRecord, qiree_create, qiree_destroy, qiree_execute,
    qiree_load_module_from_llvm_module, qiree_max_result_items, qiree_save_result_items,
    qiree_setup_executor,
};
use std::ffi::{CString, c_int};

pub fn run_mlir_module(module: Module, func_name: &str, num_shots: usize) -> Vec<ShotResult> {
    assert_ne!(num_shots, 0);

    let llvm_ctx = LLVMContext::new();
    let llvm_module =
        translate_module(module.as_operation(), &llvm_ctx).expect("translation to llvm ir failed");

    let (num_bits, results) = unsafe {
        let qiree = qiree_create();
        assert!(!qiree.is_null(), "Creating QIR-EE failed");

        let entrypoint = CString::new(func_name).expect("function name contains null byte");
        // The transmute is needed because qwerty_mlir_sys and qiree_sys each
        // have their own version of LLVMModuleRef generated by bindgen, which
        // the Rust compiler considers to be different types.
        let transmuted_llvm_module =
            std::mem::transmute::<_, qiree_sys::LLVMModuleRef>(llvm_module.into_raw());
        let ret = qiree_load_module_from_llvm_module(
            qiree,
            transmuted_llvm_module,
            entrypoint.as_bytes_with_nul().as_ptr() as *const _,
        );
        assert_eq!(ret, 0, "Loading llvm::Module into QIR-EE failed");

        let num_shots_int: c_int = num_shots.try_into().expect("too many shots");
        let mut max_items: usize = 0;
        let ret = qiree_max_result_items(qiree, num_shots_int, &mut max_items as *mut _);
        assert_eq!(ret, 0, "Asking QIR-EE for number of result records failed");

        let ret = qiree_setup_executor(
            qiree,
            "qsim".as_bytes().as_ptr() as *const _,
            std::ptr::null(),
        );
        assert_eq!(ret, 0, "Setting up QIR-EE executor failed");

        let ret = qiree_execute(qiree, num_shots_int);
        assert_eq!(ret, 0, "Executing QIR-EE failed");

        let mut results: Vec<CQireeResultRecord> =
            Vec::with_capacity(max_items.try_into().expect("too many records needed"));
        let ret = qiree_save_result_items(qiree, results.as_mut_ptr(), max_items);
        assert_eq!(ret, 0, "Executing QIR-EE failed");

        qiree_destroy(qiree);

        let header = *results.as_ptr();
        let num_bits = header.key;
        let len = header.count + 1;
        results.set_len(len.try_into().expect("too many results"));
        (num_bits, results)
    };

    let num_bits: usize = num_bits.try_into().expect("Too many bits");

    results
        .into_iter()
        .skip(1)
        .map(|CQireeResultRecord { mut key, count }| {
            let mut bits = UBig::ZERO;

            for _ in 0..num_bits {
                let bit = key & 1;
                key >>= 1;
                bits <<= 1;
                bits |= bit;
            }

            let count: usize = count.try_into().expect("Too many results");
            ShotResult {
                bits,
                num_bits,
                count,
            }
        })
        .collect()
}
