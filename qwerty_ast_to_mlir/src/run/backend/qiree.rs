use super::super::ShotResult;
use dashu::integer::UBig;
use melior::target::llvm_ir::LLVMModule;
use qiree_sys::{
    CQiree, CQireeResultRecord, QireeReturnCode, QireeReturnCode_QIREE_FAIL_EXECUTE,
    QireeReturnCode_QIREE_FAIL_LOAD, QireeReturnCode_QIREE_INVALID_INPUT,
    QireeReturnCode_QIREE_NOT_READY, QireeReturnCode_QIREE_SUCCESS, qiree_create, qiree_destroy,
    qiree_execute, qiree_load_module_from_llvm_module, qiree_max_result_items,
    qiree_save_result_items, qiree_setup_backend, qiree_setup_executor,
};
use std::{
    ffi::{CString, c_int},
    fmt,
    ops::DerefMut,
    sync::{LazyLock, Mutex},
};

const QIREE_BACKEND: &str = "qsim";

#[derive(Debug, Clone, Copy)]
pub enum QireeError {
    NotReady,
    InvalidInput,
    FailLoad,
    FailExecute,
}

impl From<&mut QireeError> for QireeError {
    fn from(err: &mut QireeError) -> QireeError {
        *err
    }
}

impl QireeError {
    pub fn from_code(code: QireeReturnCode) -> Result<(), Self> {
        if code == QireeReturnCode_QIREE_SUCCESS {
            Ok(())
        } else if code == QireeReturnCode_QIREE_NOT_READY {
            Err(QireeError::NotReady)
        } else if code == QireeReturnCode_QIREE_INVALID_INPUT {
            Err(QireeError::InvalidInput)
        } else if code == QireeReturnCode_QIREE_FAIL_LOAD {
            Err(QireeError::FailLoad)
        } else if code == QireeReturnCode_QIREE_FAIL_EXECUTE {
            Err(QireeError::FailExecute)
        } else {
            unreachable!("Unknown QireeReturnCode")
        }
    }
}

impl fmt::Display for QireeError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            QireeError::NotReady => write!(f, "QIR-EE not yet initialized"),
            QireeError::InvalidInput => write!(f, "Invalid input to QIR-EE"),
            QireeError::FailLoad => write!(f, "Failed to loading module or QIR-EE component"),
            QireeError::FailExecute => write!(f, "QIR-EE execution failed"),
        }
    }
}

pub struct Qiree {
    qiree: *mut CQiree,
}

unsafe impl Send for Qiree {}
unsafe impl Sync for Qiree {}

impl Qiree {
    pub fn new() -> Result<Self, QireeError> {
        let qiree = unsafe { qiree_create() };
        assert!(!qiree.is_null(), "Creating QIR-EE failed");

        let backend_name = CString::new(QIREE_BACKEND).expect("backend name contains null byte");
        let backend_cstr = backend_name.as_bytes_with_nul().as_ptr() as *const i8;
        let config_json = std::ptr::null();
        QireeError::from_code(unsafe { qiree_setup_backend(qiree, backend_cstr, config_json) })?;

        Ok(Self { qiree })
    }

    /// Returns the number of records to allocate for result storage
    pub fn load_module(
        &mut self,
        llvm_module: LLVMModule<'static>,
        func_name: &str,
        num_shots: usize,
    ) -> Result<usize, QireeError> {
        let entrypoint = CString::new(func_name).expect("function name contains null byte");
        let entrypoint_cstr = entrypoint.as_bytes_with_nul().as_ptr() as *const i8;
        // The transmute is needed because qwerty_mlir_sys and qiree_sys each
        // have their own version of LLVMModuleRef generated by bindgen, which
        // the Rust compiler considers to be different types.
        let transmuted_llvm_module =
            unsafe { std::mem::transmute::<_, qiree_sys::LLVMModuleRef>(llvm_module.into_raw()) };

        QireeError::from_code(unsafe {
            qiree_load_module_from_llvm_module(self.qiree, transmuted_llvm_module, entrypoint_cstr)
        })?;

        // qiree_max_result_items() must be called before
        // qiree_setup_executor() because the latter std::moves()s the module
        // into the new executor
        let num_shots_int: c_int = num_shots.try_into().expect("too many shots");
        let mut max_records: usize = 0;
        QireeError::from_code(unsafe {
            qiree_max_result_items(self.qiree, num_shots_int, &mut max_records as *mut usize)
        })?;

        QireeError::from_code(unsafe { qiree_setup_executor(self.qiree) })?;

        Ok(max_records)
    }

    /// Returns `(num_bits, records)`
    fn execute_helper(
        &mut self,
        max_records: usize,
        num_shots: usize,
    ) -> Result<(usize, Vec<CQireeResultRecord>), QireeError> {
        let num_shots_int: c_int = num_shots.try_into().expect("too many shots");
        QireeError::from_code(unsafe { qiree_execute(self.qiree, num_shots_int) })?;

        let mut records: Vec<CQireeResultRecord> = Vec::with_capacity(max_records);
        QireeError::from_code(unsafe {
            qiree_save_result_items(self.qiree, records.as_mut_ptr(), max_records)
        })?;

        // First record is the header
        let CQireeResultRecord {
            key: num_bits,
            count: num_records,
        } = unsafe { *records.as_ptr() };
        // +1 is to account for the header (the header does not count itself)
        let len = num_records + 1;
        unsafe {
            records.set_len(len.try_into().expect("too many records"));
        }

        // Remove the header in constant time by replacing it with the last record
        records.swap_remove(0);

        let num_bits_usize: usize = num_bits.try_into().expect("too many bits");
        Ok((num_bits_usize, records))
    }

    pub fn execute(
        &mut self,
        max_records: usize,
        num_shots: usize,
    ) -> Result<Vec<ShotResult>, QireeError> {
        let (num_bits, records) = self.execute_helper(max_records, num_shots)?;
        Ok(records
            .into_iter()
            .map(|CQireeResultRecord { mut key, count }| {
                let mut bits = UBig::ZERO;

                // QIR-EE uses little endian but we use big endian
                for _ in 0..num_bits {
                    let bit = key & 1;
                    key >>= 1;
                    bits <<= 1;
                    bits |= bit;
                }

                let count: usize = count.try_into().expect("Too many results");
                ShotResult {
                    bits,
                    num_bits,
                    count,
                }
            })
            .collect())
    }
}

impl Drop for Qiree {
    fn drop(&mut self) {
        unsafe {
            qiree_destroy(self.qiree);
        }
    }
}

static QIREE: LazyLock<Mutex<Result<Qiree, QireeError>>> =
    LazyLock::new(|| Mutex::new(Qiree::new()));

pub fn run_llvm_module(
    llvm_module: LLVMModule<'static>,
    func_name: &str,
    acc: &str,
    num_shots: usize,
) -> Result<Vec<ShotResult>, QireeError> {
    assert_ne!(num_shots, 0);
    assert_eq!(acc, QIREE_BACKEND, "unsupported backend {acc}");

    let mut guard = QIREE.lock().unwrap();
    let qiree = guard.deref_mut().as_mut()?;
    let max_records = qiree.load_module(llvm_module, func_name, num_shots)?;
    qiree.execute(max_records, num_shots)
}
